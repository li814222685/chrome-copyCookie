'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ChromeExtension = exports.ChromeExtension = function () {
  function ChromeExtension() {
    var _this = this;

    _classCallCheck(this, ChromeExtension);

    this.mount = function () {
      chrome.extension.onMessage.addListener(_this._messageListener);
      _this.tabPingIntervalId = setInterval(_this._tabPing, _this.tabPingInterval);
    };

    this.unmount = function () {
      clearInterval(_this.tabPingIntervalId);
      chrome.extension.onMessage.removeListener(_this._messageListener);
    };

    this._messageListener = function (request, sender, sendResponse) {
      if (_this.extId() != sender.id) return;

      Object.keys(request).forEach(function (callId) {
        if (_this.listeners[callId]) {
          _this.listeners[callId].forEach(function (listener) {
            listener(request[callId][0], request[callId][1], sendResponse);
          });
        }
      });
    };

    this._tabPing = function () {
      var callsCount = Object.values(_this.tabCalls).reduce(function (a, c) {
        return a + Object.keys(c).length;
      }, 0);

      if (!callsCount) return;

      _this.listOfTabs(function (tabs) {
        var usedTabs = Object.keys(_this.tabCalls).filter(function (tabId) {
          return Object.keys(_this.tabCalls[tabId]).length;
        }).reduce(function (a, tabId) {
          a[tabId] = 0;return a;
        }, {});

        tabs.forEach(function (tab) {
          return usedTabs.hasOwnProperty(tab.id) ? usedTabs[tab.id]++ : null;
        });

        Object.keys(usedTabs).forEach(function (tabId) {
          if (!usedTabs[tabId]) {
            Object.keys(_this.tabCalls[tabId]).forEach(function (callId) {
              return _this.tabCalls[tabId][callId]('ChromeExt tab was closed');
            });
          }
        });
      });
    };

    this.subscribeTabMessage = function (callId, listener) {
      if (!_this.listeners[callId]) _this.listeners[callId] = [];

      _this.listeners[callId].push(listener);

      return function () {
        _this.listeners[callId] = _this.listeners[callId].filter(function (item) {
          return item !== listener;
        });
      };
    };

    this.evalStringInTab = function (tabId, scriptString, callback) {
      var extId = _this.extId();
      var callIdObj = {};
      var action = function action(resolve, reject) {
        var done = function done(err, result, responce) {
          if (callIdObj.unsubscribe) callIdObj.unsubscribe();
          _this.releaseCallId(callIdObj.callId);
          if (err) reject(err);else resolve({ result: result, responce: responce });
        };
        callIdObj.callId = _this.allocCallId(tabId, function (error) {
          return done(error);
        });

        var script = '\n        (function() {\n          var callback = function(error, result, responceCallback) {\n\n            chrome.runtime.sendMessage(\n              "' + extId + '",\n              { ' + callIdObj.callId + ': [error, result] },\n              responceCallback || function(response) {\n              }\n            )\n\n          }\n\n          ' + scriptString + '\n        })()\n\n      ';

        try {
          callIdObj.unsubscribe = _this.subscribeTabMessage(callIdObj.callId, function (error, result, responceCallback) {
            done(error, result, responceCallback);
          });
          chrome.tabs.executeScript(tabId, { code: script }, function (result) {
            if (chrome.runtime.lastError) {
              return done(chrome.runtime.lastError.message || 'evalStringInTab chrome undefined error');
            }
            if (!result) {
              done('Error chrome.tabs.executeScript, probably no such tab');
            }
          });
        } catch (e) {
          done('Error ' + e.name + ":" + e.message + "\n" + e.stack, undefined, function () {});
        }
      };

      if (callback) return action(function (err) {
        return callback(err);
      }, function (_ref) {
        var result = _ref.result,
            responce = _ref.responce;
        return callback(undefined, result, responce);
      });else return new Promise(action);
    };

    this.listeners = {};
    this.nextCallId = 0;
    this.releasedCalls = [];
    this.tabCalls = {};
    this.callToTab = {};
    this.tabPingInterval = 15 * 1000;
    this.instanceId = 'awaiting';
    chrome.tabs.getCurrent(function (tab) {
      if (tab) _this.instanceId = tab.id;
    });
    console.log(chrome.extension.getURL("popup.html"));
  }

  _createClass(ChromeExtension, [{
    key: 'callAction',
    value: function callAction(action, callback) {
      if (typeof callback !== 'function' && typeof callback !== 'undefined') throw Error('callback must be a function');
      if (typeof action !== 'function') throw Error('action must be a function');
      if (callback) return action(function (err) {
        return callback(err);
      }, function (res) {
        return callback(undefined, res);
      });else return new Promise(action);
    }
  }, {
    key: 'extId',
    value: function extId() {
      return chrome.runtime.id;
    }
  }, {
    key: 'allocCallId',
    value: function allocCallId(tabId, errorHandler) {
      var callId = this.releasedCalls.length ? this.releasedCalls.pop() : '_' + this.instanceId + '_' + ++this.nextCallId;

      if (!this.tabCalls[tabId]) this.tabCalls[tabId] = {};
      this.tabCalls[tabId][callId] = errorHandler || function () {
        return console.warn('allocCallId error handler was not specified');
      };

      this.callToTab[callId] = tabId;

      return callId;
    }
  }, {
    key: 'releaseCallId',
    value: function releaseCallId(callId) {
      var tabId = this.callToTab[callId];
      delete this.tabCalls[tabId][callId];
      if (!Object.keys(this.tabCalls[tabId]).length) delete this.tabCalls[tabId];

      delete this.callToTab[callId];

      this.releasedCalls.push(callId);
    }
  }, {
    key: 'tabCallCount',
    value: function tabCallCount(tabId) {
      return this.tabCalls[tabId] ? Object.keys(this.tabCalls[tabId]).length : 0;
    }
  }, {
    key: 'listOfTabs',
    value: function listOfTabs(callback) {
      var action = function action(resolve, reject) {
        try {
          chrome.tabs.query({}, function (tabs) {
            resolve(tabs);
          });
        } catch (e) {
          reject(e);
        }
      };
      return this.callAction(action, callback);
    }
  }, {
    key: 'listOfCurrentWindowTabs',
    value: function listOfCurrentWindowTabs(callback) {
      var action = function action(resolve, reject) {
        try {
          chrome.tabs.query({ currentWindow: true }, function (tabs) {
            resolve(tabs);
          });
        } catch (e) {
          reject(e);
        }
      };
      return this.callAction(action, callback);
    }
  }, {
    key: 'currentTab',
    value: function currentTab(callback) {
      var action = function action(resolve, reject) {
        try {
          // https://developer.chrome.com/extensions/tabs#method-query
          var queryInfo = {
            active: true,
            currentWindow: true
          };

          chrome.tabs.query(queryInfo, function (tabs) {
            var tab = tabs[0];

            // See https://developer.chrome.com/extensions/tabs#type-Tab
            var url = tab.url;
            console.assert(typeof url == 'string', 'tab.url should be a string');

            resolve(tab);
          });
        } catch (e) {
          reject(e);
        }
      };
      return this.callAction(action, callback);
    }
  }, {
    key: 'closeTab',
    value: function closeTab(tabId, callback) {
      var action = function action(resolve, reject) {
        try {
          chrome.tabs.remove(tabId, function () {
            if (chrome.runtime.lastError) {
              return reject(chrome.runtime.lastError.message || 'closeTab chrome undefined error');
            }
            resolve();
          });
        } catch (e) {
          console.warn('close chrome tab ' + e.message);
          reject(e);
        }
      };
      return this.callAction(action, callback);
    }
  }, {
    key: 'openTab',
    value: function openTab(url, active, callback) {
      var action = function action(resolve, reject) {
        try {
          chrome.tabs.create({ url: url, active: active }, resolve);
        } catch (e) {
          console.warn('open chrome tab ' + e.message);
          reject(e);
        }
      };
      return this.callAction(action, callback);
    }
  }]);

  return ChromeExtension;
}();